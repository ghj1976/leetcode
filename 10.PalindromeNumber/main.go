package isMatch

import "fmt"

// mississippi
// mis*is*ip*.
func isMatch(s string, p string) bool {
	for i := range p {
		// 匹配一次就消耗
		// mississippi
		// mis*is*ip*.
		//     🔽
		// s 经过三次消耗策略  自上而下的动态规划消耗策略 每次消耗,只返回消耗最多的策略,并且吧 (mis*  is*  ip*) 消耗掉
		// mis*  is*  ip*
		// =================================================================
		// 1. for 循环 (mis*) 第一次组合消耗策略, 并返回min(最短长度的s)
		// s 经过 (mis*) 消耗策略
		// s 经过 (m)(is*) 消耗策略
		// s 经过 (mi)(s*) 消耗策略
		// =================================================================
		// 2. for 循环 (is*) 第二次组合消耗策略, 并返回min(最短长度的s)
		// s 经过 (is*) 消耗策略
		// s 经过 (i)(s*) 消耗策略
		// =================================================================
		// 3. for 循环 (ip*) 第二次组合消耗策略, 并返回min(最短长度的s)
		// s 经过 (ip*) 消耗策略
		// s 经过 (i)(p*) 消耗策略
		// =================================================================
		// s 如果经过上面三次消耗,("结果"==""?true:false)


		fmt.Println(i)
	}
	return len(s) == 0
}
